# 从单体到微服务



## 单体架构时代

### 后端通包的早期时代

![02](https://image-hosting.jellyfishmix.com/20201207103617.jpeg)

这是 web 1.0 的时代，最经典的 client - server 架构。浏览器展示的网页为 client 端，负责供用户操作、展示数据。服务器为 server 端，负责处理 client 提交的请求和数据。

这种逻辑是清晰的，并且是易于实现的，因此自然而然成为了最早期的架构模型。

而团队的规模通常也比较小，10人以下，团队内部也不区分前后端。界面由 java 工程师或 php 工程师在后端生成，浏览器负责展现对应的页面。浏览器基本上是 server 提供什么，浏览器就展示什么。而 URL 到页面的映射由 server 端的 web 服务器来负责。

这样的架构模型虽然简单易于实现，但业务规模总会增大，伴随着业务规模的增大，团队规模也会逐渐增大。

在这种背景下，会遇到一些典型的问题：

1. 前端页面和后端服务冗杂在一起，由于整个项目是一个单体应用，每次修改后都需要重新编译整个项目，牵一发而动全身。天哪，我只是想调整下按钮样式，却要本地开发、代码上传、验证生效等好几个步骤。也许习惯了也还好，但开发服务器总是不那么稳定，出问题时往往需要依赖后端开发搞定。看似仅仅是前端开发难以本地化，但这对研发效率的影响其实蛮大。
2. 前端页面越来越冗杂，由于此种架构还没有衍生出专业的前端分工，页面大多由后端程序员来写。后端程序员也负责写 server 服务，很容易会把服务逻辑代码写入 jsp，造成前后端逻辑冗杂在一起。违反了单一指责原则，耦合度很高，对扩展、修改皆不友好。

### 后端为主的 MVC 时代

随着业务规模的增大和团队规模的增大，View 层页面代码和 server 服务代码冗杂在一起的复杂度问题，越来越突出，已经影响到了开发进度。变化理所当然的发生了。

Web server 层进行了架构升级，诞生了不少 MVC 框架，例如：Structs、Spring MVC 。

![04](https://image-hosting.jellyfishmix.com/20201207103753.jpeg)

代码可维护性得到明显好转，MVC 是个非常好的协作模式，从架构层面让开发者懂得什么代码应该写在什么地方。为了让 view 层更简单干脆，还可以选择 Velocity、Freemaker 等 view 层页面模板，页面模版里写不了 java 代码，强制性让页面和服务代码分离的更干脆。虽然这样看起来是减弱了功能，但其实正是这种强制解耦，使得页面代码和服务代码分离的更清晰，为日后专业前后端的分工奠定了基础。

这个阶段依然是过渡阶段，尚不成熟，典型的问题有：

1、前端开发重度依赖开发环境。这种架构下，前后端协作有两种模式：一种是前端写 demo，写好后，让后端去套模板。淘宝早期包括现在依旧有大量业务线是这种模式。好处很明显，demo 可以本地开发，很高效。不足是还需要后端套模板，有可能套错，套完后还需要前端确定，来回沟通调整的成本比较大。另一种协作模式是前端负责浏览器端的所有开发和服务器端的 View 层模板开发，支付宝是这种模式。好处是 UI 相关的代码都是前端去写就好，后端不用太关注，不足就是前端开发重度绑定后端环境，环境成为影响前端开发效率的重要因素。

2、前后端职责依旧纠缠不清。Velocity 模板还是蛮强大的，变量、逻辑、宏等特性，依旧可以通过拿到的上下文变量来实现各种业务逻辑。这样，只要前端弱势一点，往往就会被后端要求在模板层写出不少业务代码。还有一个很大的灰色地带是 Controller，页面路由等功能本应该是前端最关注的，但却是由后端来实现。Controller 本身与 Model 往往也会纠缠不清，看了让人咬牙的代码经常会出现在 Controller 层。这些问题不能全归结于程序员的素养，否则 JSP 就够了。

### Ajax 带来的 SPA 时代

2005年，Ajax 正式被提出，加上 CDN 的大量应用，SPA （Single Page Application 单页面应用）登上了舞台。

![05](https://image-hosting.jellyfishmix.com/20201207104747.jpeg)

这种模式下的关键点是 ajax 接口，这个接口能让前端页面和 server 进行网络通信，传输数据。这样可以把静态页面缓存进 CDN，用户使用浏览器访问静态页面后，通过交互操作调用 ajax 接口和后端进行数据交互。

虽然这种模式看起来美妙，但如今回头来看，与 JSP 时代区别不大。复杂度从后端的 view 层转移到了浏览器端的页面。当然这在后来会继续改善。

这种模式下，职业的前端分工终于诞生了。后端不用一边写服务代码一边写页面的html，可以更加专注于服务代码。

这个阶段存在的问题有：

1. 前后端接口的约定。这个时候前后端没有严格的接口规范，如果后端业务模型不稳定或接口写得混乱，那么前端会很痛苦。每次一个接口调整，就牵扯到前端与此接口交互的大量代码的修改适配。
2. 前端复杂度太高。这个阶段前端是以功能交互为主，需要自行将数据与后端交互后，变更到视图上，而这一个过程，如果设计如何处理，还没有一个规范。这导致了前端开发模式尚处混乱之中。

### 前端为主的 MVC 时代

为了降低前端的开发复杂度，规范开发流程，大量的框架涌现出来：如 AngularJS 等，这些框架的理念是按类型分层，比如  Templates、Controllers、Models，层内根据需求再细分。

![07](https://image-hosting.jellyfishmix.com/20201209091512.jpeg)

这样的分层好处很明显：

1. 前后端分工更加明确。前端工作在浏览器端，后端工作在服务端。清晰的分工，可以让开发并行，测试数据的模拟不难，前端可以本地开发。后端则可以专注于业务逻辑的处理，输出 RESTful 等接口。
2. 前端代码的复杂度可控。通过规范让前端代码能各司其职，更好地把代码组织起来。
3. 可以独立部署，前端修改后无需与后端一起重新编译。

但此时依然存在不足之处：

1. URL Design 需要后端配合，前端无法自主设计。
2. SPA 不能满足所有需求，依旧存在大量多页面应用。

### Node 带来的全栈时代

随着 Node.js 的兴起，JavaScript 开始有能力运行在服务端。这意味着可以有一种新的研发模式：

![08](https://image-hosting.jellyfishmix.com/20201209092316.png)

在这种模式下，前后端的职责很清晰。对前端来说，浏览器的 UI 层和 node UI 层各司其职：

1. 浏览器的 UI 层负责处理展现逻辑。通过 JavaScript 添加交互功能，通过 CSS 渲染样式，HTML 的生成也可以放在这层，具体看应用场景。
2. node UI 层处理路由、模板、数据获取、cookie 等。通过路由，前端终于可以自主把控 URL Design，这样无论是单页面应用还是多页面应用，前端都可以自由调控。后端也终于可以摆脱对展现的强关注，转而可以专心于业务逻辑层的开发。

node UI 层也是 JavaScript 代码，这意味着部分代码可前后复用，比如前端对参数的判空校验，后端也需要进行判空校验，由于 node 也使用 js 编写，可以直接复用前端的参数判空校验。

当然 node.js 也对前端提出了新的要求：

1. 需要前端对服务端编程、计算机网络有更多的认知。
2. 对运维部署层面的熟练了解，需要更多知识点和实操经验。



## 多实例

理论上来说此种架构模型还处在单体应用范畴内，只不过是把一个单体应用在多个服务器上启动了对应的多个实例，在接收请求的前方设置一个负载均衡来分流数据请求，避免流量过大把单个应用服务器冲垮。好处是显而易见的，大大提升了整体服务的流量承载压力。

### 应用实例与数据库负载分配

![img](https://image-hosting.jellyfishmix.com/20201111120105.jpg)

这张图是一个最常见的中型网络服务的架构示意图。

每一个应用服务器，跑着一个应用程序实例（应用程序就是咱们写的后端代码）。前面有负载均衡负责把流量分流给应用实例们。

从这张图能看出，应用实例理想情况下，是可以无限扩展的（就是可以起很多个实例）。

但是数据库使用主从库结构（主库写，从库读），理想情况下负责读的库可以有很多台，但负责写的数据库只有一台（这是出于事务管理的考虑）。

所以优化的通常思路是，尽量让更多的负载位于应用实例上，而不是位于数据库上。原因就像前面提到的，理想情况下，应用实例可以起很多个，但是写数据库只有一台。

当把负载逻辑更多地分配给应用层后，主数据库服务器（写） 上的负载有了显著的降低：

![2541605066477_.pic](https://image-hosting.jellyfishmix.com/20201111115828.jpg)

但是应用服务器的负载提升了，这时候怎么办呢？只要再加几台应用服务器就好了。



## 微服务

微服务领域的两位祖师爷 Martin Fowler 和 James Lewis，在2014年对一种新的架构风格——微服务（微服务这个术语最早诞生2011年在威尼斯召开的一次软件架构师工作坊）提供了完整的定义。随着他们的定义，微服务这种架构风格迅速地成为软件行业的热词，并被许多互联网公司采纳，陆续开始迈入微服务的演进过程。

这是原文：

In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.

翻译后：

简而言之，微服务架构风格是一种将单个应用程序开发为一组小服务的方法，每个小服务都在自己的进程中运行并与轻量级机制（通常是HTTP资源API）进行通信。 这些服务围绕业务功能构建，并且可以由全自动部署机制独立部署。 这些服务的集中管理几乎没有，它可以用不同的编程语言编写并使用不同的数据存储技术。

这便是两位大叔给微服务的定义，很准确。

### 拆分

![四种软件架构：单体架构、分布式架构、微服务架构、Serverless架构| 戴树谦的博客](https://image-hosting.jellyfishmix.com/20201209104727.png)

注册中心：服务是分散在不同机器上的，需要注册中心来负责记录服务的信息，当然服务中心并不仅限一个，服务中心也可以起多个实例，互相注册。

配置中心：也是由于服务的拆分、分散，配置文件的数量也增加了，如果一个个地修改管理，会消耗大量精力成本。配置中心应运而生，负责统一管理各个服务的配置信息，除此之外还可以支持不停止服务动态修改服务的配置文件。

消息队列：分布式的数据通信拓扑比较复杂，且有些数据是需要保证可靠交付的，HTTP 协议并不能保证这一点。HTTP request 需要被即时处理，如果服务负载压力较大可能导致超时失败，且一旦请求失败便会导致请求丢失。像订单这种与钱相关的敏感重要数据，必须保证可靠交付。在这种需求下，消息队列诞生了。在消息队列中，request 的对应概念是一个消息，消息会被存储在队列中。消息队列还引入了 生产者-消费者 模式，生产者负责产生消息，消费者负责订阅消息并消费。

### CAP理论

Consistency（一致性）

一致性意味着所有客户端都可以同时看到相同的数据，无论它们连接到哪个节点。为此，无论何时将数据写入一个节点，都必须立即将其转发或复制到系统中的所有其他节点，然后再将写入视为“成功”。

Availability（可用性）

服务在正常响应时间内一直可用。

Partition Tolerance（分区容错性）

分区是分布式系统内的通信中断，即两个节点之间的连接丢失或暂时延迟。分区容限意味着即使系统中节点之间发生了许多通信故障，群集也必须继续工作。

对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。

对于涉及到钱财这样不能有一丝让步的场景，C必须保证。网络发生故障宁可停止服务，这是保证CA，舍弃P。还有一种是保证CP，舍弃A。例如网络故障事只读不写。

CAP理论决定没有完美的解决方案，三者间的权衡需要根据场景来判断，适合的才是最好的。

### 规范

在开发面向微服务的应用程序时，需要遵循以下规则：

1. 独立-每个微服务应可独立部署。 

2. 耦合-所有微服务都应彼此松散耦合，以使其中一项更改不会影响另一项。 

3. 业务目标-整个应用程序的每个服务单元应最小，并能够交付一个特定的业务目标。

### 好处

1. 体积小-微服务是SOA设计模式的一种实现。建议您尽可能多地保留服务。基本上，一项服务不应执行一项以上的业务任务，因此，与任何其他整体应用程序相比，该服务的大小显然较小，并且易于维护。
2. 专注-如前所述，每个微服务仅设计为交付一项业务任务。在设计微服务时，架构师应关注服务的重点，即它的可交付性。根据定义，一种微服务在本质上应该是全栈的，并且应该致力于仅交付一种业务资产。
3. 自治-每个微服务都应该是整个应用程序的自治业务部门。因此，应用程序变得松散耦合，这有助于降低维护成本。
4. 技术异质性-微服务支持在一个业务部门中彼此通信的不同技术，这有助于开发人员在正确的位置使用正确的技术。通过实施异构系统，可以获得最大的安全性，速度和可伸缩的系统。
5. 弹性-弹性是隔离软件单元的属性。微服务遵循高水平的构建方法弹性，因此，只要一个单元发生故障，它就不会影响整个业务。弹性是实现高可扩展性和较少耦合的系统的另一个属性。
6. 易于部署-由于将整个应用程序细分为小部分，因此每个组件本质上都应该是完整堆栈。与其他同类单片应用程序不同，它们可以很容易地以较少的时间复杂性部署在任何环境中。

分布式系统-由于技术的多样性，将使用不同的技术来开发微服务的不同部分。

### 缺点

1. 分布式系统-由于技术的多样性，将使用不同的技术来开发微服务的不同部分。需要大量熟练的专业人员来支持这种大型的异构分布式软件。因此，分布式和异构性是使用微服务的第一个缺点。

2. 成本-微服务的成本很高，必须为不同的业务任务维护不同的服务器空间。这些服务空间通常需要实体硬件条件的支撑，这是一笔不小的费用。
3. 评判标准-随着技术的日新月异，微服务架构可以被视为不同技术的综合体。 因此，很难使微服务应用程序企业准备好与传统软件开发模型进行比较。



## 引用

谈谈分布式系统的CAP理论 - 崔同学的文章 - 知乎，2018

Web 研发模式演变——玉伯，2014

