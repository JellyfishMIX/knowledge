# JVM结构



## 主要组成

- 程序计数器（Program Counter）： 代码行号指示器。
- Java堆（Heap）：存放对象实例。
- Java栈（Stack）：存储基本类型，局部变量。
- 本地方法栈（Native Stack）：为执行native方法服务。
- 方法区（Method Area）：存储已被虚拟机加载的类信息，常量，静态变量。



## 结构组成

###方法区

#### 类信息(Class Data)

类信息存储在方法区，其主要构成为运行时常量池(Run-Time Constant Pool)和方法(Method Code)。

##### 运行时常量池(Run-Time Constant Pool)

运行时常量池是方法区的一部分。Class文件中有类的版本，字段，方法，接口等描述信息和用于存放编译期生成的各种字面量和符号引用。这部分内容将在类加载后存放到方法区的运行时常量池中。Java虚拟机规范对Class的细节有着严苛的要求而对运行时常量池的实现不做要求。一般来说除了翻译的Class,翻译出来的直接引用也会存在运行时常量池中。

运行时常量池具备动态性，即运行时也可将新的常量放入池中。比如String类的intern()方法。

常量池无法申请到足够的内存分配时也会抛出OutOfMemoryError。

### 代码缓存(Code Cache)

用于编译和存储那些被 JIT 编译器编译成原生代码的方法。

### off-heap 堆外内存

off-heap叫做堆外内存，将你的对象从堆中脱离出来序列化，然后存储在一大块内存中，这就像它存储到磁盘上一样，但它仍然在RAM中。这些内存直接受操作系统管理（而不是虚拟机）。不属于老年代和新生代。

JVM GC回收堆和方法区对象在这种状态下不能直接使用，它们必须首先反序列化，也不受垃圾收集器管理。序列化和反序列化将会影响部分性能（所以可以考虑使用FST-serialization）。

某些时候，VM必须执行所谓的“ Full GC”。完整的GC涉及扫描完整分配的堆，这意味着GC的暂停/减速与应用程序堆大小成正比。

因此保持一个较小的堆就有必要了。off-heap（堆外内存）就是服务于这个目的。

#### 直接内存（Direct Memory）

直接内存并不在Java虚拟机规范中，不是Java的一部分，但是也被频繁使用并可能导致OutOfMemoryError。Native函数库可以直接分配堆外内存，通过存储在Java堆里的DirectDataBuffer对象作为这块内存的引用进行操作。这样做在一些场景中可以显著提高性能。

直接内存是堆外内存，自然不受Java堆大小的限制，但是可能受实体机内存大小的限制。如果内存各部分总和大于实体机的内存时，也会报出OutOfMemoryError。



## JVM线程与原生线程的关系

JVM允许一个程序使用多个并发线程，Hotspot JVM中Java的线程与原生操作系统的线程是直接映射关系。即当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。run() 返回时，被处理未捕获异常，原生线程将确认由于它的结束是否要终止 JVM 进程（比如这个线程是最后一个非守护线程）。当线程结束时，会释放原生线程和 Java 线程的所有资源。

