# Java内存模型



## 概念

JAVA内存模型即JMM（Java Memory Model），有些人会和Java内存结构混淆。虽然两者名字很接近，但描述的为不同内容。Java内存结构描述的是JVM对内存的逻辑划分，我们在学习垃圾回收和JVM优化的时候会关心JVM内存结构。而本节所讲的JMM，实际上是一种规范。它描述了Java程序的运行行为，包括多线程操作对共享内存读取时，所能读取到的值应该遵守的规则。

- JVM 内存结构，描述的是逻辑结构。

- JVM 内存模型 ，描述的是 运行行为，多线程读取内存读取的是什么值。JMM 为程序操作定义了 规则，Happens-Before 
  实际上是一套执行顺序。



## Happens-Before规则

Happens-Before在多线程领域具有重大意义，它可以指导你如何开发多线程的程序，而不至于陷入混乱之中。你所开发的多线程程序，如果想对共享变量的操作符合你设想的顺序，那么需要依照Happens-Before原则来开发。happens-before并不是指操作A先于操作B发生，而是指操作A的结果在什么情况下可以被后面操作B所获取。下面我们就来看一下Happens-before原则。

1. 程序顺序规则。如果程序中A操作在B操作之前，那么线程中A操作将在B操作前执行。
2. 上锁原则。不同线程对同一个锁的lock操作一定在unclock前。
3. volatile变量原则。对于volatile变量的写操作会早于对其的读操作。
4. 线程启动原则。A线程中调用threadB.start()方法，那么threadB.start()方法会早于B线程中中的任何动作执行。
5. 传递规则。如果A早于B执行，B早于C执行，那么A一定早于C执行。
6. 线程中断规则：线程interrupt()方法的一定早于检测到线程的中断信号。
7. 线程终结规则：如果线程A终结了，并且导致另外一个线程B中的ThreadA.join()方法取得返回，那么线程A中所有的操作都早于线程B在ThreadA.join()之后的动作发生。
8. 对象终结规则：一个对象初始化操作肯定先于它的finalize()方法。

我们只有充分理解了happens-before原则，才能在编写多线程程序的时候，尽量避免数据的不一致性，让多线程程序在必要的时候按照我们设计的次序执行。

这8条原则摘自《深入理解Java虚拟机》。这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。

- 第1条解释：注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。

- 第2条解释：无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。
- 第3条解释：如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。
- 第4条解释：体现happens-before原则具备传递性。



## 引用/参考

[ Java并发编程学习宝典 - 13 - 李一鸣 - 慕课网](https://www.imooc.com/read/49/article/940)

[ Java并发编程学习宝典 - 13 - Youn_g，啊穆的评论 - 慕课网](https://www.imooc.com/read/49/article/940)