# Unicode与UTF



## Unicode

Unicode 目前规划的总空间是17个平面（平面0至16），0x0000 至 0x10FFFF。每个平面有 65536 个码点（正好填充2个字节，16位）。

所谓「Unicode 只有两个字节」这种说法，只是知道平面0（「Basic Multilingual Plane」，即「BMP」）的 65536 个码点（即 0x0000 至 0xFFFF）如何编码，这不是 Unicode 的全部。

- BMP 的字符是 Unicode 中最基础和最常用的一部分，以 UTF-16 编码时使用2字节，以 UTF-8 编码时使用1至3字节。
- 超出 BMP 的字符以 UTF-16 或 UTF-8 编码都需要4字节。
- 另外还有一个比较少用的编码形式，UTF-32，它编码任何 Unicode 字符都需要4个字节。

Unicode 的基础是一个编号的字符集，在字符集之上又规定了模块化的编码等等技术层次，各种具体的编码形式并不一致，「Unicode 只有两个字节」这句话根本不成立。



## UTF-8

UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码，又称万国码。



## 解析

很多人都把Unicode编码挂在嘴边，其实咱们现实生活中遇到的编码基本都是Unicode的 

因为Unicode兼容了大多数老版本的编码规范例如 ASCII 

Unicode编码定义了这个世界上几乎所有字符（就是你眼睛看到的长那个样子的符号）的数字表示 

也就是说Unicode为每个字符发了一张身份证，这张身份证上有一串唯一的数字ID确定了这个字符 

在这个纷乱世界上存在的唯一性。Unicode给这串数字ID起了个名字叫**［码点］（Code Point）**

而很多人说的编码其实是想表达**［Unicode转换格式］（即UTF，Unicode Transformation Formats）**

有没有觉得眼前一亮豁然开朗？没错 这就是我们看到的UTF-8/UTF-16/UTF-32的前缀来源 

这个［Unicode转换格式］的存在是为了解决［码点］在计算机中的二进制表现形式而设计的 

毕竟我们的机内表示涉及存储位宽，兼容古老编码格式，码点是数值过大的罕见字符等问题 

［码点］经过映射后得到的二进制串的转换格式单位称之为**［码元］（Code Unit）**。也就是说如果有一种UTF的码点二进制表示有n字节，其码元为8位（1个byte），那么其拥有码元n个。每种UTF的码元都不同，其宽度被作为区分写在了UTF的后缀——这就是UTF-8/UTF-16/UTF-32的由来。UTF-8的码元是8位的，UTF-16的码元是16位的。大部分的编程语言采用16位的码元作为机内表示。这就是我们在各种语言中调用获取一个字符串中character的数量时会出现这么多混乱的原因。事实上我们调用这些方法时取得的不是字符个数，而是**码元个数**！一旦我们的字符串中包含了位于基本平面之外的码点，那么就会需要更多的码元来表示，这个时候就会出现测试时常见的困惑——为何return的字符数比实际字符数要多？所以实际写代码时要特别注意这个问题。 

采取不同的映射方式可以得到不同格式的二进制串，但是他们背后所表示的［码点］永远是一致的就好像你换身份证但是身份证号不变一样。由于平时人们误把［转换格式］也称为［编码］，所以造成今天Unicode／UTF傻傻分不清楚且遣词造句运用混乱的悲桑局面。 

Unicode 编码 发展到今天 扩展到了 21 位（从 U+0000 到 U+10FFFF ）。这一点很重要： **Unicode** **不是** **16** **位的编码，** 它是 21 位的。这 21 位提供了 1,114,112 个码点，其中，只有大概 10% 正在使用，所以还有相当大的扩充空间。 

编码空间被分成 17 个**平面**（plane），每个平面有 65,536 个字符（正好填充2个字节，16位）。0 号平面叫做**「基本多文种平面」（** **BMP,** **Basic Multilingual Plane** **）**，涵盖了几乎所有你能遇到的字符，除了 emoji（emoji位于1号平面 - -）。其它平面叫做补充平面，大多是空的。 

总结一下各种编码格式的特质： 

**UTF-32**

最清楚明了的一个 UTF 就是 UTF[-](http://en.wikipedia.org/wiki/UTF-32)32 ：它在每个码点上使用整 32 位。32 大于 21，因此每一个 UTF-32 值都可以直接表示对应的码点。尽管简单，UTF-32却几乎从来不在实际中使用，因为每个字符占用 4 字节太浪费空间了。 

**UTF-16** **以及「\**\*对」（** **Surrogate Pairs** **）的概念**

UTF[-](http://en.wikipedia.org/wiki/UTF-16)16要常见得多，它是根据有 16 位固定长度的**码元（** **code units** **）**定义的。UTF-16 本身是一种长度可变的编码。基本多文种平面（BMP）中的每一个码点都直接与一个码元相映射。鉴于 BMP 几乎囊括了所有常见字符，UTF-16 一般只需要 UTF-32 一半的空间。其它平面里很少使用的码点都是用两个 16 位的码元来编码的，这两个合起来表示一个码点的码元就叫做***\**对（** **surrogate pair** **）**。 

**UTF-8**

UTF-8 使用一到四个字节来编码一个码点。从 0 到 127 的这些码点直接映射成 1 个字节（对于只包含这个范围字符的文本来说，这一点使得 UTF-8 和 ASCII 完全相同）。接下来的 1,920 个码点映射成 2 个字节，在 BMP 里所有剩下的码点需要 3 个字节。Unicode 的其他平面里的码点则需要 4 个字节。UTF-8 是基于 8 位的码元的，因此它并不需要关心字节顺序（不过仍有一些程序会在 UTF-8 文件里加上多余的 BOM）。 

有效率的空间使用（仅就西方语言来讲），以及不需要操心字节顺序问题使得 UTF-8 成为存储和交流 Unicode 文本方面的最佳编码。它也已经是文件格式、网络协议以及 Web API 领域里**事实上**的标准了。 

我们的JVM中保存码点是UTF16的转换格式，从char的位宽为16位也可以看得出来。由于绝大部分编码的码点位于基本平面，所以使用16位可以几乎表示所有常用字符。这就是许多语言编译器或运行时都使用UTF16的原因。英文在使用UTF16时也是2字节表示的。当我们想要使用其他平面的字符时，码元超过2个字节，就需要使用***对在语言中的特定表示方式，譬如‘\U112233’之类的。 

使用UTF8时，常用的Alphabet和Numeric都在前127字节，被有效率地用一个字节表示。而我们的中文由于排在1920个码点之后，所以使用3个字节表示，这方面就比UTF16转换格式耗费更多空间。 

最后，不论使用哪种UTF转换格式，都是程序员自己可以选择的一种表达方式而已。我们可以通过Java方便的API进行自如转换。



## 参考

[R0b1n的回答-牛客网](https://www.nowcoder.com/profile/938383901/myFollowings/detail/12945719)