# 死锁



## 概念

死锁指的是因为某种原因，达不到解锁的条件，导致某线程对资源的占有无法释放，其他线程会一直等待其解锁，而被一直 block 住。



## 产生死锁的原因

- 交叉死锁

  A 线程持有资源 R1 的锁时，想要获取 R2 的锁。而线程 B 此时持有 R2 的锁，想要获取 R1 的锁。结果就是两个线程互相等待对方释放，并且一直等待下去。

- 内存不足

  某系统内存 20M，两个线程正在分别执行任务，各自已经使用了 10M 内存。但是执行到一半时需要更大的内存，但是系统已经没有内存可供使用。那么两个线程都会等待对方执行完毕 时释放内存。这就造成了两个线程互相等待，从而形成死锁。

- 一问一答式的数据交换

  所谓的一问一答式数据交换就是客户端发送请求，服务端返回响应。如果在交互过程中出现了数据的丢失，双方产生误解，以为对方没有收到消息，陷入等待之中。如果此时没有设置 timeout，就会造成互相的等待一直持续下去，从而形成死锁。

- 数据库锁

  如果某个线程对数据库表或者行加锁，但是意外导致没能正确释放锁，而其他线程则会等待数据库锁的释放，从而陷入死锁。

- 文件锁

  某个线程获取文件锁后开始执行。但是执行过程中意外退出，而没能释放锁。那么其他等待该文件锁的线程将会一直等待，直到系统释放文件句柄的资源。

- 死循环

  假如某个线程，由于编码问题，在对资源加锁后，陷入死循环，导致一致无法释放锁。



## 引用/参考

[ Java并发编程学习宝典 - 14 - 李一鸣 - 慕课网](https://www.imooc.com/read/49/article/940)