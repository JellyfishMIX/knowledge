# 事务



## ACID

事务具备 4 个特性：

- 原子性（Atomicity）

  事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行（有始有终）

- 一致性（Consistency）

  事务应确保数据库的状态从一个一致状态转变为另一个一致（有效）状态。一致（有效）状态的含义是数据库中的数据应满足完整性约束（表里如一）

- 隔离性（Isolation）

  多个事务并发执行时，一个事务的执行不应影响其他事务的执行（井水不犯河水）。

- 持久性（Durability）

  已被提交的事务对数据库的修改应该永久保存在数据库中（一诺千金）。

简称ACID。



## 脏读，幻读，不可重复读

- 脏读

  脏读就是一个事务（A）读到了另一个事务（B）未提交的数据。

  如果一个事务（A）读到另一个事务（B）并未提交的数据，恰好事务（B）由于某些原因导致了事务回滚，那么刚刚事务（A）就相当于读到了实际并不存在的数据。很显然，这种情况是存在问题的。

- 不可重复读

  不可重复读通常针对数据更新（UPDATE）操作。不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。

- 幻读

  幻读指的是在同一个事务内进行多次操作之间，另一个事物插入了新的数据，并对后续的操作造成了影响。

  - 幻读是针对数据插入（INSERT）操作来说的。在同一个事务中，同一个查询语句多次执行，返回的结果不一致。事务A新增了一条记录，事务B在事务A提交前后各执行了一次查询操作，发现后一次比前一次多了一条记录。
  
  - 幻读是由于并发事务插入记录导致的，这个不能像不可重复读通过记录加锁解决，因为对于尚未插入的记录根本无法加锁。需要将事务串行化，才能避免幻读。



## 隔离级别

下面是不同隔离级别与发生读问题的关系对照表：

| 隔离级别                     | 脏读   | 不可重复读 | 幻读   |
| :--------------------------- | :----- | :--------- | :----- |
| 读未提交（Read uncommitted） | 可能   | 可能       | 可能   |
| 读已提交（Read committed）   | 不可能 | 可能       | 可能   |
| 可重复读（Repeatable read）  | 不可能 | 不可能     | 可能   |
| 可串行化（Serializable）     | 不可能 | 不可能     | 不可能 |

- 读未提交 (Read Uncommitted)：所有读问题都可能发生，一般不会使用这种隔离级别。

- 读已提交 (Read Committed)：只能避免脏读的情况发生，Oracle 的默认隔离级别。

  提交读因为只能读取已经提交的数据，所以可以避免脏读，但是不保证事务重新读的时候能读到相同的数据，因为在每次数据读完之后其他事务可以修改刚才读到的数据，所以不能避免不可重复读和幻读现象

- 可重复读 (Repeated Read)：能够避免脏读和不可重复读，MySQL 中 InnoDB 引擎默认的隔离级别。

- 串行 (Serializable)：可以解决所有读问题，但由于是串行执行，性能相当一般，所有通常也不会被使用。

### Read Committed和Repeated Read

MySQL 中的提交读和可重复读两个隔离级别是使用多版本并发控制 MVCC 来实现的，而不是通过添加读写锁来实现的，如果通过读写锁来实现隔离级别的话，只有读读可以并发，读写，写读，写写都不能并发，这样数据库的并发度太低了，所以一般不通过加读写锁来实现隔离级别。而如果使用 MVCC 来实现 提交读和可重复读两个隔离级别的话则可以在读的时候不加锁，读写和写读可以同时进行，只有写写需要阻塞，这样就极大地提高了并发度。

MVCC 机制会记录每行数据的历史版本，通过可见性算法、undo 日志以及 read view 控制每个读操作所读取的行数据历史版本，

`Read Committed` 在事务中每次读操作都是读取最新的行数据版本，而这最新的数据行版本很可能是某个事务进行了修改操作后提交的，所以可能会发生多次读取同一行数据，但是前后读取的数据不一致的情况。这就是不可重复读现象，所以提交读不能避免不可重复度现象。

`Repeatable Read` 在事务发生第一次读的时候选定所要读取的数据行的版本，整个事务都读取这一个版本的数据行，所以可以重复读，每次读取的数据都一致。


