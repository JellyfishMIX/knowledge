# mysql 索引



**问题 1：MySQL 支持哪些存储引擎？**

**参考答案：**

MySQL 支持的存储引擎主要有四种：

（1）**InnoDB** 支持事务，行级锁定和外键，是事务型数据库的首选引擎；MySQL5.5.5 之后的默认存储引擎；

(2）**MyISAM** 拥有较高的插入、查询速度，但不支持事务。MySQL5.5.5 之前的默认存储引擎；

（3）**Memory** 基于散列，存储在内存中，对临时表有用。常见的应用场景是：临时存放数据，数据量不大，并且不需要较高的数据安全性；

（4）**Archive** 支持高并发的插入操作，但是本身不是事务安全的。常见的应用场景：存储归档数据，如记录日志信息可以使用 Archive。

**追问：InnoDB 和 MyISAM 有什么区别呢？**

（1）InnoDB 支持事务；而 MyISAM 不支持事物，强调的是性能，查询速度更快；

(2）InnoDB 支持行级锁和表级锁（默认行级锁），而 MyISAM 只支持表级锁；

（3）InnoDB 支持 MVCC, 而 MyISAM 不支持 MVCC；

（4）InnoDB 支持外键，而 MyISAM 不支持外键；

（5）InnoDB 早期版本不支持全文索引（从 MySQL5.6 开始支持全文索引），而 MyISAM 支持；

（7）InnoDB 不保存表的具体行数，count () 时要扫描一遍整个表来计算有多少行；MyISAM 则内置了一个计数器，count () 时它直接从计数器中读。

**点评：**

这类 “相同点与不同点” 的问题之前出现过多次，这里对这类问题也稍作一下总结，这类问题呢通常大家都是机械式罗列一二三四，这样回答不能说是错误，但是很难出彩。在面试中针对任务问题都**不要表现出现死记硬背的样子**，可以从三个方面进行着手：**一是在语义不失真的情况下尽量口语化一些；二是将各个小点与自己生产实践有机结合，比如说自己在什么情况使用了 MyISAM（当然没有的话就算了）等；三是结合 MySQL 的版本特点，说说 MySQL 最新版本的信息，向面试官透露候选人是经常关注热点技术的人**。在此基础上，不同点是七个还是五个反而没那么重要。

再回到这个问题，MySQL 实际上还支持 BLACKHOLE、CSV 等存储引擎（可通过 SHOW ENGINES 命令查看），不过很小众，就不再展开了。

在 MySQL 中，**索引就是在存储引擎层实现的**，不同存储引擎的索引的工作方式并不一样，即使不同的存储引擎支持同一种类型的索引，其底层的实现也可能不同。而这些存储引擎中以 InnoDB 应用最广泛，很多面试题也围绕着它展开。

**问题 2：MySQL 索引底层是什么结构？为什么采用此结构？**

mysql 底层采用 B + 树的存储结构。采用 B + 树的原因：

（1）索引文件很大，不能全部存储在内存中，只能存储到磁盘上，因此索引的数据结构要尽量减少查找过程中磁盘 I/O 的存取次数；

（2）数据库系统利用了磁盘预读原理和磁盘预读，将一个节点的大小设为等于一个页，这样每个节点只需要一次 I/O 就可以完全载入。而 B + 树的高度是 2~4，检索一次最多只需要访问 4 个节点（4 次，即树的高度）。

**点评：**

数据结构不是凭空产生的，一定会有它的背景和使用场景。那么理想的索引数据结构就需要把磁盘 IO 次数控制在一个很小的数量级，最好是常数数量级。显然一个高度可控的多路搜索树符合此要求，b + 树应运而生。**事实上，B + 树索引并不能直接找到具体的行，只是找到被查找行所在的页，然后 DB 通过把整页读入内存（磁盘预读），再在内存中查找（局部性原理，即当一个数据被用到时，其附近的数据也通常会马上被使用）。**

*为什么不适用 B 树？*

下面两张图分别是 B 树和 B + 树的示意图，可以看出有一个很大的区别：B + 树所有的 Data 域在叶子节点，其余节点用来索引，而 B 树是每个索引节点都会有 Data 域；并且 B + 树所有叶子节点之间都有一个链指针。 这样遍历叶子节点就能获得全部数据，从而支持区分查询。在数据库中基于范围的查询是非常频繁的，而 B 树不支持这样的遍历操作。

B树：

![B tree](https://image-hosting.jellyfishmix.com/20201024130911.png)

B+树：

![B Plus tree](https://image-hosting.jellyfishmix.com/20201024130935.png)



*为什么不用哈希表？*

（1）哈希表只适用与查找等值查询， 不能支持区分条件（大于小于查询）、模糊查询等；

（2）hash 索引虽然在等值查询上较快，但是不稳定，性能不可预测，当某个键值存在大量重复的时候，发生 hash 碰撞，此时效率可能极差。而 B + 树的查询效率比较稳定。

*为什么不用红黑树？*

红黑树往往高度过大，从页造成磁盘 IO 读写过于频繁，效率低下。而且逻辑上很近的节点（父子）物理上可能很远，无法利用局部性原理。

**问题 3：MySQL 支持的索引类型是哪些？**

**参考答案：**

（1）**普通索引**：用表中的普通列构建的索引，没有任何限制；

(2）**唯一索引**：唯一索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一；

（3）**主键索引**：是一种特殊的唯一索引，根据主键建立索引，不允许重复，不允许空值；

（4）**全文索引**：通过过建立倒排索引，快速匹配文档的方式。MySQL 5.7.6 之前仅支持英文，MySQL 5.7.6 之后支持中文；

（5）**组合索引**：又叫联合索引。用多个列组合构建的索引，这多个列中的值不允许有空值。可以在创建表的时候指定，也可以修改表结构。

**追问：了解聚集索引和非聚集索引吗？**

（1）**聚集索引 (clustered index)**，又称为主索引，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。因为数据真正的数据只能有一种排序方式，所以一个表上只能有一个聚簇索引。

（2）**非聚集索引 (secondary index)**，又称为辅助索引、普通索引，该索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表可以包含多个非聚集索引。

**点评：**

聚集索引 / 非聚集索引不是一种索引类型，而是一种存储数据的方式。在 InnoDB 中它们还有一个非常重要的区别：聚集索引的叶子节点的的 data 域包含了完整的数据记录，而非聚集索引的叶子节点的 data 域记录着主键的值，因此在使用非聚集索引进行查找时，需要先查找到主键值，然后再到聚集索引中进行查找，这称之为**回表查询**。

**问题 4：索引什么时候会失效？**

**参考答案：**

索引失效通常有以下原因：

（1）条件中有 or；

（2）like 查询（以 % 开头）；

（3）如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引；

（4）对列进行函数运算（如 where md5 (password) = “xxxx”）；

（5）负向查询条件会导致无法使用索引，比如 NOT IN,NOT LIKE,!= 等；

（6）对于联合索引，不是使用的第一部分 (第一个)，则不会使用索引（最左匹配）；

（7）如果 mysql 评估使用全表扫描要比使用索引快，则不使用索引；。**追问 1**：表 A 建立了 INDEX (col1,col2,col3) 的联合索引，where 条件中使用 col1 = a1 and col3=c1 索引是否有效？

索引有效。

**点评：**

这里涉及联合索引的最左前缀匹配原则，顾名思义，它是指在检索数据时从联合索引的最左边开始匹配。如果你创建一个了联合索引 (col1, col2, col3)，那么该索引的任何前缀都会用于查询，即 (col1), (col1, col2), (col1, col2, col3) 都会使用索引查询。

其实最左匹配原则也是和 B + 树的结构相关，比如使用 (col1, col2, col3) 上述索引，B + 树是按照从左到右的顺序来建立搜索树的，比如当检索 (‘a1’,‘b1’,‘c1’) 时，B + 树会优先比较’a1’再来确定下一步的搜索方向，如果 col1 相同再依次比较 col2 和 col3，最后得到检索的数据；但当检索 (‘b1’,‘c1’) 这样的没有 col1 的数据时，B + 树就不知道第一步该查哪个节点，所以不能使用索引。而当检索 (‘a1’,‘c1’) 时，B + 树可以用 col1 来指定搜索方向，即使下一个字段 col2 缺失，也能把所有 col1='a1’的数据找出来，然后再匹配 col3='c1’数据。

**追问 2：索引有什么缺点？**

参考答案：

（1）索引需要额外的占用物理空间，索引越多，所以空间越多。

（2）当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的写入速度。



## 引用/参考

[高薪之路--Java面试题精选集 - jiehao -慕课网](https://www.imooc.com/read/67#catalog)